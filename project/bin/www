#!/usr/bin/env node

/**
 * Module dependencies.
 */
var tmp = require('../app');
var app = tmp.app;
var server = tmp.server;
var io = tmp.io;

// var app = require('../app');
var debug = require('debug')('project:server');
var dbmanager = require('../dbmanager');

/**
 * Listen on provided port, on all network interfaces.
 */
server.on('error', onError);
server.on('listening', onListening);

// usernames which are currently connected to the chat
var usernames = {};
var listOfPlayers = {};
var sessions_ip = [];

/** DEBUG **/
//var util = require('util');


/** SOCKET IO **/
io.sockets.on('connection', function (socket) {

  socket.on('signup', function (team) {
    console.log("[Sign Up] Received : " + JSON.stringify(team));

    dbmanager.teams.exists({"name": team.name}, function (exists) {
      console.log(exists);

      if (exists) // Already existing team
        socket.emit('signup', {"status": false});
      else // Team available
        team.score = 0;
      dbmanager.teams.add(team, function () { // Adding team
        socket.emit('signup', {"status": true}); // Team added
        dbmanager.teams.get(function (data) {
          io.sockets.emit('getteams', data);
        }, {}, socket.request.headers.behavior);
      }, socket.request.headers.behavior);
    }, socket.request.headers.behavior);
  });

  socket.on('signin', function (data) {
    console.log("[Sign In] Received : " + JSON.stringify(data));

    dbmanager.teams.exists(data, function (team) {
      console.log(team);
      if (team.length || 0) // Team exists
        socket.emit('signin', {"status": true, "admin": (team[0].name === "admin")});
      else // Team doesn't exists
        socket.emit('signin', {"status": false});
    }, socket.request.headers.behavior);
  });

  socket.on('getteams', function (filter) {
    console.log(socket.request.headers.behavior);
    dbmanager.teams.get(function (data) {
      console.log("[Get Teams] Received");
      socket.emit('getteams', data);
    }, filter, socket.request.headers.behavior);
  });

  socket.on('getenigmas', function () {
    dbmanager.enigmas.get(function (data) {
      console.log("[Get Enigmas] Received");
      socket.emit('getenigmas', data);
    }, {}, socket.request.headers.behavior);
  });

  socket.on('addenigma', function (enigma) {
    console.log("[Add Enigma] Received");
    console.log(JSON.stringify(enigma));
    dbmanager.enigmas.add(enigma, function () { // Adding enigma
      dbmanager.enigmas.get(function (data) {
        io.sockets.emit('getenigmas', data);
      }, {}, socket.request.headers.behavior);
    }, socket.request.headers.behavior);
  });

  socket.on('solveenigma', function(data){
    console.log("[Solve enigma] Received");
    console.log(JSON.stringify(data));
    dbmanager.teams.solve(data.enigma_id, data.team_name, data.won, function(res) {
      if(res !== false)
        dbmanager.teams.get(function (data) {
          socket.emit('getteams', data);
        }, {}, socket.request.headers.behavior);
    });
  });

  socket.on('removeteam', function (id) {
    console.log("[Remove Enigma] Received");

    console.log(id);
    dbmanager.teams.remove(id, function () { // Adding enigma
      dbmanager.teams.get(function (data) {
        io.sockets.emit('getteams', data);
      }, {}, socket.request.headers.behavior);
    }, socket.request.headers.behavior);
  });

  socket.on('removeenigma', function (id) {
    console.log("[Remove Enigma] Received");

    console.log(id);
    dbmanager.enigmas.remove(id, function () { // Adding enigma
      dbmanager.enigmas.get(function (data) {
        io.sockets.emit('getenigmas', data);
      }, {}, socket.request.headers.behavior);
    }, socket.request.headers.behavior);
  });


    socket.on('addsessionip', function (data) {
        console.log("[Add Session] " + JSON.stringify(data));
        sessions_ip[data.ip] = data.name;
    });

    socket.on('getsessionip', function (data) {
        console.log("[Get Session] " + JSON.stringify(data));

        var res = {};

        if (!(data.ip || 0))
        {
            console.log("data.ip undefined!");
            socket.emit('getsessionip', {status: false});
            return;
        }

        res.status = sessions_ip.hasOwnProperty(data.ip); //contains?
        res.name = (res.status) ? sessions_ip[data.ip] : "YOU HACKER!";

        console.log("--> " + JSON.stringify(res));
        socket.emit('getsessionip', res);
    });

    socket.on('removesessionip', function(data) {
      console.log("[Remove Session] " + JSON.stringify(data));
      if (!(data.ip || 0))
      {
        console.log("data.ip not found");
        return;
      }

      if (sessions_ip.hasOwnProperty(data.ip))
        delete sessions_ip[data.ip];
    });

  socket.on('sendchat', function (data) {
    io.sockets.emit('updatechat', socket.username, data);
  });

  socket.on('sendpos', function (newPos) {
    socket.broadcast.emit('updatepos', socket.username, newPos);
  });

  socket.on('adduser', function (username) {
    socket.username = username;
    usernames[username] = username;
    socket.emit('updatechat', 'SERVER', 'you have connected');
    socket.broadcast.emit('updatechat', 'SERVER', username + ' has connected');
    io.sockets.emit('updateusers', usernames);

    var player = {'x': 0, 'y': 0, 'v': 0};
    listOfPlayers[username] = player;
    io.sockets.emit('updatePlayers', listOfPlayers);
  });


  socket.on('disconnect', function () {

    delete usernames[socket.username];
    io.sockets.emit('updateusers', usernames);

    delete listOfPlayers[socket.username];
    io.sockets.emit('updatePlayers', listOfPlayers);

    socket.broadcast.emit('updatechat', 'SERVER', socket.username + ' has disconnected');
  });
});

/**
 * Event listener for HTTP server "error" event.
 */
function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
  console.log('Listening on ' + bind);
}
